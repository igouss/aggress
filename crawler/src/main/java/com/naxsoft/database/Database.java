//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by Fernflower decompiler)
//

package com.naxsoft.database;

import org.hibernate.*;
import org.hibernate.boot.Metadata;
import org.hibernate.boot.MetadataSources;
import org.hibernate.boot.registry.StandardServiceRegistry;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import rx.Observable;
import rx.functions.Func1;

/**
 * Database abstraction.
 */
public class Database implements AutoCloseable, Cloneable {
    private final static Logger LOGGER = LoggerFactory.getLogger(Database.class);
    private static final int BATCH_SIZE = 20;
    private final SessionFactory sessionFactory;

    /**
     *
     */
    public Database() {
        try {
            StandardServiceRegistry e = (new StandardServiceRegistryBuilder()).configure().build();
            Metadata metadata = (new MetadataSources(e)).getMetadataBuilder().build();
            this.sessionFactory = metadata.getSessionFactoryBuilder().build();
        } catch (Exception e) {
            LOGGER.error("Failed to create hibernate session factory", e);
            throw e;
        }
    }


    /**
     * Close connection to the underling database
     */
    public void close() {
        if (null != this.sessionFactory) {
            this.sessionFactory.close();
        }

    }


    /**
     * @param action
     * @param <R>
     * @return
     */
    public <R> R executeQuery(Func1<StatelessSession, R> action) {
        StatelessSession session = null;
        R result = null;
        try {
            session = sessionFactory.openStatelessSession();
            result = action.call(session);
        } finally {
            if (null != session) {
                session.close();
            }
        }
        return result;
    }

    /**
     * @param action
     * @param <R>
     * @return
     */
    public <R> R executeTransaction(Func1<StatelessSession, R> action) {
        StatelessSession session = null;
        org.hibernate.Transaction tx = null;
        R result = null;
        try {
            session = sessionFactory.openStatelessSession();
            tx = session.beginTransaction();
            result = action.call(session);
            tx.commit();
        } catch (Exception e) {
            if (null != tx) {
                tx.rollback();
            }
            LOGGER.error("Transaction failed", e);
            throw e;
        } finally {
            if (null != session) {
                session.close();
            }
        }
        return result;
    }

    /**
     * Avoid loading whole result set generated by the query. Instead iterate over scrollable result set
     *
     * @param queryString SQL query to execute
     * @return Stream of elements returned by SQL query.
     */
    public <T> Observable<T> scroll(String queryString) {
        return Observable.using(sessionFactory::openStatelessSession,
                session -> doScroll(queryString, session),
                StatelessSession::close);
    }

    /**
     * Avoid loading whole result set generated by the query. Instead iterate over scrollable result set
     *
     * @param queryString SQL query to execute
     * @param session     Database session
     * @return Stream of elements returned by SQL query.
     */
    private <T> Observable<T> doScroll(String queryString, StatelessSession session) {
        return Observable.using(() -> getScrollableResults(queryString, session),
                Database::scrollResults,
                ScrollableResults::close);
    }

    /**
     * Avoid loading whole dataset, instead use scrollable result.
     *
     * @param queryString SQL query to execute
     * @param session     Database session connection
     * @return Scrollable result generated by the query
     */
    private static ScrollableResults getScrollableResults(String queryString, StatelessSession session) {
        Query query = session.createQuery(queryString);
        query.setCacheable(false);
        query.setReadOnly(true);
        query.setFetchSize(BATCH_SIZE);
        LOGGER.info("Scroll SQL {}", query.getQueryString());
        ScrollableResults results = query.scroll(ScrollMode.FORWARD_ONLY);
        return results;
    }

    /**
     * Get the observable result. Rows are loaded one at time from the database.
     *
     * @param result Record set over which to iterate
     * @return Observable result stream
     */
    private static <T> Observable<T> scrollResults(ScrollableResults result) {
        return Observable.<T>create(subscriber -> {
            while (!subscriber.isUnsubscribed() && result.next()) {
                LOGGER.info("Scroll row# {}", result.getRowNumber());
                T t = (T) result.get(0);
                if (null == t) {
                    subscriber.onError(new Exception("Unexpected result"));
                } else {
                    subscriber.onNext(t);
                }
            }
            subscriber.onCompleted();
        });
    }
}


